
combining two graphs gives us lots of disjunct domains
how can we actually combine the domains directly; or rather - when does it make sense to?

when you're binding something in the same disjunct as yourself

on one side, there's a binding against a var of two disjunct domains; on the other side there'sonlyone disjunct domain

and so we multiply em: yielding a product of two furhter disjuncts (disjuncts are never anulled but by disproof)

if there's only one on each side, then there's only one product - simple

BUT! there's the complication here of different envs

on the left, each domain is coupled with two subgraphs; on the right there's one, linking to one single graph (the same as the current effectively)


if there's one at each side, then these multiply together into one
do worlds always get merged then?

it would seem so...
at least in combining graphs

-----

how do we add a disjunction then? any narrows into a disjunction - either because we assign it explicitly or a relation decrees it (the same thing)

a disjunction is a result of propagation

-----------------------

but we now confront the origin of this whittle: do the separate envs truly get squashed into one another by this merge?

the problem with doing so is that we are merging an entire graph at a time here - all the registrations in the dictionary of each are cross-related

we proceed linearly and can't just jump into another env here

in fact it would seem that the original idea was to merge kinda by propagation

which militates against the piecemeal combination of fragments here that was going to be our method
well, it doesn't... it's actually perfectly fine

each small fragment still needs merging in, accumulating, aggregating as before; it's just our method of doing so must be finessed

--------

propagation goes node by node, whereas this kind of merging happens across the entire surface of the graphs, at once

when we say that this world is true, and that this true is a also true, we a aren't speaking about one part of the graph in particular, but across its whole, all at the same time

so if we are to propagate, we should be propagating them all at precisely the same time

second best thing: go through them one by one, merging them and makingsure they all et propagated

-----

domain disjunctions are then multiplied; but what of portset disjunctions - the first layer of choice?

we find a port as it is represented on the left and on the right

on the left it is bound to two possible portsets; on the right only to one. Onboth sides it has only one domain

in the new combined graph, this port will be related to - the product of these disjunctions again

So each possible combination of left portset * right portset is tried
and within these, each possible combination of left domain * right domain
this is a lot of product

Port
Portset * Portset
Domain * Domain

is this per port? because it should be that portsets are shared, or at least reciprocated
but we don't mutate round here

maybe the indexing by port is a luxurious nicety, not an essential part of the structure. The essence is a set of portsets over a field of ports
we might want to look up portsets from each port (even then, I'm not sure we actually would ever want this...)

a fragment with a singly-bound sole port is but a very small floating portset and its referred-to port beside it

portsets are what we have - and they overlap

-------

so a graph is a collection of portsets, with backlinks from port to portset derived from this


-------------------------------------------------------------

but there are choices between portsets too
not just domains have disjunctions
but portsets too

how do you choose between portsets? 
you must start with a port, everything starts from a point, even a general merging 

merging two graphs: each portset on one side multiplies with each overlapping portset on the other
and the way to do this is to go through port links one by one

each portset is as real as any other
portsets can only overlap within a map if protected by a disjunction

overlapping portsets will only be merged, will only know each other, 

propagation can't alter portsets - can it?
well, propagation can activate, make flow new graphs
isn't that a merging in of a new graph? it certainly seems so

on one side, a load of portsets; on the right, loads of portsets
every overlapping portset must combine

but if there's no overlap, then the portset still survives
which is odd

the portsets themselves can't multiply then, as otherwise they would be annihilated
they must be thought of as adding together

but then, if there are multiple worlds of them...

where actually did we get the idea that there'd be multiple worlds of portsets?
from subgraphs being suddenly made available? they will mechanically be poured into the system; no tracking of possibilities needed here

well - this isn't the case
given a disjunct domain on a portset in one graph, subgraphs may be activated by only some options
such a subgraph may extend the triggering portset itself

in which case, the one activating disjunct amongst others may be a window into a world where the very situating portset is altered
(though only monotonically)

by choosing this disjunct, we enter a world, a graph, where the binding is different - no problems here

this means portsets live in the different obliquely linked layers of each graph

--------

the root graph is like an index of subgraphs: each one is available at the ports it affects, via the choice of a domain 'nose'

so from the off, what we have is indeed a big map of individual ports

no! not ports, but portsets, again; but still, we access via the individual port

how do we know about anything unless wehae a port in the beginning?
we look at a port, and a port has a choice of portsets, though each portset has a domain; in fact one portset can have multiple possible domains

the index per port at the root level is the conceived portset/domain disjunction but inside out
like the root index is the puckered skin of a fish(?!) tightly torqued

at the root, given a port, we choose from its domains, and each domain comes with its own followable world
this world, if we were to follow it, is our entrance into a portset - we can have no portset without choosing a world from the disjunction first

soa disjunction at the root has a collection of domains with worlds

the discovered world is in the first instance - a portset with a set domain
suddenly we have access now to the peers of the port in this scheme of things

if weare propagating for whatever reason, we can now by the links of relations (the owners of the port legs see) find our way to other disjunct spaces

but we choose first of all, and make our way /to/ a portset: the portset isn't choosable in itself; after all, how would we distinguish them?

---------

this is how choices are presented, not just for end consumption by sampling, but for the propagating mechanism too

is this how the data actually is however? currently the portset forms part of the nose of the disjunct, the peeping through of the alternate world
yet we will only ever care about disjuncts and qualities of the disjuncts once we've enumerated them; in fact I'm not even sure we ever really care about the nose
if a disjunct is there, we have to enumerate it; what we find there is what we find there

but this is it, the choosing, and what snippets of info we pick up through our choosing - this is the one and only way of gathering portset and domain; we don't find these bits of information
restated anywhere; we choose the portset, which puts us in contact with others, and we choose the domain of the portset we'll be going with; after that point we have the means of finding other ports
in the set in this world (the world has been gathered piecemeal through the choosing); at this point we can happily propagate to the sibling ports; though we also need to contextualise our call to them
port by passing it a reference to where we are: the packaged tuplised env is just a signpost, a signal that will limit other bindings that we may see

so we do choose the portset first

-----------

at a disjunction (which is on a port, not a portset - the port is the first site of choice) we choose a portset (like milking an ewe) then a domain, and having ranged so far, we find the contextualised graph to now carry with us

but we also want to fold graphs into each other - the first thought with this was that we should enumerate all ports on each, but are the portsets more real in fact?

the portsets are zones, and are real; each domain lives on a portset; so on a graph we have our portsets; these portsets don't live in a set, but in a map against ports
each graph is in fact a dictionary of ports with portsets

-------------

we want to merge small graphs together; so a good starting point would be deciding what the smallest graph would look like

the smallest graph would quite simply have a single binding, a single port with a single domain
a single portset, a single domain in that portset, and that domain would point back to the current root

if two such tiny graphs converge, then what?
the portsets are the true things, but the portsets can only be compared by their ports

and a portwise comparison of portsets can be done using the same port->portset index surely

we enumerate the ports in play; all portsets on the left are combined with all portsets on the right; each combination creates another graph, partially zipped;
the enumeration of course keeps track of ports that have been seen;

instead of creating new graphs on each small combination, it would be better to batch operations; 
so - instead of creating new graphs, we should be building a list of portsets to be combined, or rather - a list of independent combinations
the actual combining and registering of these portsets can be done at once at the end

but what would these intermediate structures be, if not something very similar, in fact identical in function, to the immutable structures of more permanent storage

but, though the portsets would be the same, and are reasonably updated in place, indexes also must be updated
in fact each update is the same here; each time we add anything we have to update the heads here

first of all we find overlaps; this is done by, as we were saying, enumerating all port->portset indices on both sides, grouped by port
we find an entry on both left and right sides: this means the portsets overlap somewhat, and should be joined in the new graph we are contextually building up

we aggregate what - an entirely new graph? no need to be entirely new; we can build to the left or to the right
we can build to the left by default, though dome efficiency would be gained by building onto the larger graph each time

we go one by one through the available ports, adding more and more onto the left graph

but if we find an overlap, we should combine not just that one port, but the entire portset right there, uprooting its indices (by some mechanism)

we have two accumulators, one increasing, one diminishing
when a portset is found to overlap, it must be transplanted as a whole and removed from the right side
and added to the portsets of each implicated port on the left

but in doing so we will lose disjunctions on the right-hand side
as we will afterwards enumerate ports previously touched by the now transplanted portsets,
which through their transplantation now only appear on the left side as pristine

this is the problem of using the left side as source and accumulator at once
solution: zip together into one common accumulated output graph
portsets are moved wholesale as soon as they are discovered

-------------------------------------------------------------------

as each portset is transplanted over, all of its registrations with ports on its sources must be take with it
similarly, new indices must be immiediately created on the destination graph

each time a portset is taken, it should bring with it, like flypaper, any matching portsets from the other side
this means that a train of portsets will be merged together at one time

they will also be uprooted at the same time
in fact it might be that the entire set of portsets on both sides is pulled out as one awkward length
leaving us just to enumerate empty ports thereafter


-------------------------------------------------------------

*merging*

if the ports were ordered, then everything could be ordered
and ports, as reference types, do have a natural order

do we want to update the index as we go on? the index could even be lazily generated
though it is needed for this merging also

it would be best of all if we could merge in to the biggest graph
the fewer updates the better

which goes against the grain of the previous approach of extracting systems of groups whole; instead we patch up to achieve the same

how can we do this? by extending current groups
and by adding new groups

we'd go through the groups on the right, and for each,
find intersecting groups on the left; these groups are now to be joined and extended

though - it is certainly easier to implement the full-reindex-on-each-merge approach (though ghastly)

------

operations to merge

right -> left
- add new graph (as a special case of the below)
- extend groups with new groups

that's about it - movement will always be towards expansion

for each group on the right,
find intersecting groups on the left

and extend the selected set of groups using the right hand side group

can't we just add the new group then? the problem with this is that, if there are multiple groups on the right, the second to be applied will find everything already smudged

multiple groups on the right would be projected to new groups on the left

each group on the right as found should be applied separately in parallel to the left graph
this begets a selection of new graphs that can be themselves combined

not combined, but added, as overlapping groups from this point shouldn't be made to touch; should exist in isolation from each other

two phases: combination and addition

--------

combination is done by taking each right-hand group and joining it in - yielding each time an independent result, a projection of the left map
these would then be 'added' together

a problem here is needing to add the full graph each time

would be better if only the implicated groups were in the first place projected
but then we'd be in the business of creating loads of intermediate structures again
better to deal in lazy thunks here, that can be applied at one time (at the end) to the one accumulating graph

so each right hand group is taken one by one
and, instead of application in parallel, is applied, aggregated in series

though - more like the gathering of applicable left groups is done in parallel, but the final application is done once only
and the final application is exactly when the indexing happens - once only, and accumulative

so we gather the groups first: how? each group on the right is of course represented, and all else being equal each righthand group would be added as a completely separate group on the left side, accruing indexing as we go

but each time an intersecting left hand group is found, then we're not about adding a completely new group, only extending an existing one
which is a separate kind of operation of course

but in this case if there are two right groups to apply overlapping, these will create the same operation duplicated: here we have to create a brand new group and index it in
the first extends the existing, but the second has to be freshly applied

this is op-by-op approach: fiddly special cases all the way through
though the domain is limited, the special cases are obvious and well-known: we can make sure we handle all of them

----------

- for each right group,
	- extend each intersecting left group
	- but if there are overlapping groups to join on the left, then we need to maintain the choice of possibilities here

!!!
Even if there is only one group on the right, there's the chance of complication here:
if a right group stands to join a single group with two overlapping groups, both on the left, how do we do this????

(1,2)__(2)
(3,4)  (4)


here the two left groups don't overlap 
we summon the right group
and join the new group to the existing groups

which involves removing all old groups and their indices,
and adding the new ones - simple enough
removing and then readding isn't that much of a bind

so that's simple enough
------

the problem was with overlaps, because with overlaps there's an implied choice
that we must maintain


(1,2)        (2,4)
  (2,3)
                
in this case, 
the one new group shouldn't join the groups that it finds,
but apply to them separately
this is because the two left groups are actually in disjunction
(if you imagine a big dividing line between them)

whereas the two above aren't, being instead on the same plane

part of me wants to encode disjunctions more explicitly into the graph,
though they are deducible as is: any overlap means disjunct

although this makes me worry again: 
if we have alternate worlds we can choose between, surely the consistency of these worlds is across the provided graph, not just per group?

though, across thew graph, if there is only one choice against a certain port, then it must be true
but, in the above case, if that were so, then both (1,2) /and/ (2,3) would have to be true at the same time, as (1) and (3) insist on one each

they can't float alongside each other like this, with the rule that one choice against one port means that must be true

when we choose a disjunction, that should be a consistent view of the world
not sure here: the idea's always been to have choices on choices: you don't immediately find global simplicity, though you do always step in the right direction

what we imagine to ourselves when we think of a graph is always the index: a selection of choices against ports
that's what we see

when we, starting from a port, choose a particular portset, we don't just choose that one portset, but a selection of others that all make sense with it
this is what we were hiding behind the domain choice, as a consolidated choice: choose a portset, choose a domain, get a more consistent world

except now we're trying to tackle the portset choice in isolation, but with the same shape of choice

-----

as part of a composite choice, what role do the portsets play?

well, we want to index them, which does mean disjunction here

our simplified model here has portsets but no domains, which we would like to build as a second increment

but it still has the idea of choice; in choosing we still get a simplified graph of portsets
if we have choice, then multiple overlapping portsets need to live alongside each other somehow;
and they can't just live in the same shared hashset, as this misses all linkages between them

we fall back to our previous kitchensink approach, only this time without the full worktop:
a structure of layered scopes, with lookup delegated to the root level from above
this allows commonly-available portsets to be found, even when we're traversing more particular spaces
	
-----

and back to our original problem here: the steady building up of graphs from atoms

A(1,2)       C(1)
  B(2,3)      (3)

on the left side, two portsets are opposed: both cannot be true
so when we lookup (2), we get both back as choices

when we lookup (1) however, it would seem we also get a choice between two: either nil or (1,2)
does this mean on (2) too we have the choice of nil, and actually have three possibles?

as a chooser we maybe always have the choice of 'no' - we don't have to bind anything, though choosing 'no'
gets us nowhere - returning us to our starting position only.

so having an indexed option there doesn't mean it has to be true: it is in fact suspended

-------

idea yesterday was that indices are projections of an underlying structure
now i'm wondering if this true; the real structure is indeed a graph

on the left then, we have two portsets, that certainly exist as portsets, in states of situated independence

if we were to combine in the right hand side, then each such set, if it touched the same ports, would be affected
though by being extended, other portsets might also be folded in at this point from the left

the above is a reasonable example scenario: let's flesh it out

A(1,2)       C(1)
  B(2)        (3)

1: A    |  1: C
2: A,B  |  
3:      |  3: C

the only choice is on (2), between A and B
if we choose A, we find ourselves in a subgraph (subindex?) with only A

similarly C, by itself, is a fragment with only C
if it was added to A's fragment, we'd get this:

1: A C
2: A
3:   C

which would be the two subgraphs, but now joined by a common root index
adding would then just be a case of wrapping two fragments with a global index

but what if the two graphs don't overlap? consider B + C:

1:   C
2: B
3:   C

in this case, if we chose 2:B, then we'd get a lonely graph of only one entry,
but if we then enquired after (1), our enquiry would be delegated back to the root graph as we have made no choice on that matter:
with delegation we'd then always get:

1: C
2: B
3: C

------

1: A   C
2: A B   
3:     C

if we chose 1:C then delegation on (2) would give us A|B
which is surely wrong, as we have disproved A
on the rejection of a group, it should be removed from the possibles on offer

so we don't just delegate to the original root: we in fact create a brand new graph with choices both positively and negatively narrowed

if C was in its own fragment, we could continue with that, as long as we changed the root scope to remove the rejected group
or - we could do both changes at once to create a single environment to work with

so when we make a choice, we actually obliterate the current graph; we chisel it down

this leads us back to the thought of having groups in a set, and then maintaining an index to them
the index is then not just a secondary nicety, but an integral part of tracking choices
when you make a choice, you both choose and reject, and the graph changes to match this choice

------------------------

back to the problem of combining:

1: A   C     AC
2: A *    =  AC
3:     C     AC


1: A B     C     AC BC
2: A    *  C  =  AC BC
3:   B              BC


1: A           A
2:    *     =  
3:       C       C

if it wasn't so with this 'multiplication', combining together non-overlapping graphs would always leave us with nothing
maybe emptiness should be thought of as unity, not null

--

if we have it as so, then how will propagation work? propagation will make choices, and create simpler and simpler graphs for itself;
it will still be possible for itself to return its findings however, for a remerge into the master

---

so 
- sets of groups that can be added and combined, with an updating of indices after
- also a mechanism for making choices


1: A             CA
2: A       C     CA CB
3:      *     =  
4:   B     C     CA CB
5:   B              CB

1: A             CAB
2: A       C     CAB
3:      *     =  
4: B       C     CAB
5: B             CAB

this then doesn't work...

we want C to join the disparate portsets of A and B
because A and B arent actually in disjunction, they just need bridging

I suppose merging could implicate all touched by C, all at once: we'd firstly gather all implicated portsets, then merge them all into one big supergroup

1: A             CAB
2: A       C     CAB
3:      *     =  
4:   B     C     CAB
5:   B           CAB

but then...

1: A             CAB
2: A B     C     CAB
3:      *     =  
4: A B     C     CAB
5:   B           CAB

this ignores the disjunction between A and B at (2) and (3)



1: A             CA
2: A       C     CA CB
3:      *     =  
4:   B     C     CA CB
5:   B              CB

1: A             CAB
2: A       C     CAB
3:      *     =  
4: B       C     CAB
5: B             CAB

how to differentiate between the above?

there's actually no way to express the first example above: how can the portsets be presented in disjunction if they don't overlap
(unless we make disjunction fundamental to the structure)

if we use the per-port indices as our sources of structure, then it's inexpressible, anyway
and indeed do we want to be able to express it?

------

why would we have choices of portsets? because under different conditions, in different subgraphs, different bindings will be activated
but these choices are always in subgraphs

we still want them to be represented in the root index here, but their structuring comes from the nesting and situating of the graphs themselves
so a portset will always be flat?

given a port, we nevertheless have a choice of portsets: each such choice becomes a partial shortcut to another subgraph where this portset holds true

it's the separation again between the true structure of things and the secondary projection by which we regather that structure

what we get after the choice is a groupmap that corresponds with our choice - but it is an environment with further choices embedded within it
we don't suddenly break through to a world of simple, clear reality; rather things have just simplified partially; we're still in the world of disjunctions

we return to our previous conception:
a root graph absorbs all the possibilities of the subgraphs above it

a graph is always a mapping of ports to choices; if we're dealing only in bindings, and not associated values, then in a graph a port has a choice of portsets
but when choosing a portset from the selection of available portsets against a port, what we do is find ourselves in a slightly simpler graph
in this slightly simpler graph, if we try to find the choices against a port that is untouched by the subgraph, we delegate back to the root

though the root may have choices that are incompatible with the choice already made on entering the subgraph: the only thing to do in this instance is to
not delegate to the root, but to a simplified root cleaned of what has been explicitly rejected
the counterpart to the subgraph is calculated as a backing to the subgraph

-----

this is all good in the abstract, but what kind of data structure is this? it is supremely discoverable, but we now want to compose it from atoms

firstly, the simplest graph: one port has one possible portset, that includes itself only; on choosing this one possiblity (hm this is actually the implicit zero case)

let's try again; the simplest graph: two ports with a single portset possibility; on choosing this, we get a subgraph that is in fact the same as the root

but now, what has changed? I want to say that the ports attached by the portset now have no choice: there is only the chosen portset as before; in this case, we find ourselves
back at the root; the root has linked to itself, there is non need for a subgraph here
and anyway, we don't consult the map directly, rather we extract info from it via the choice itself; its just we acknowledge the effect of our choice

so, a single port with a portset of itself only is a kind of identity, saying nothing, as this binding is always available.
a binding without choice is offered on top of the useless possibility of identity

but what of a graph with choice?
well: a port is either connected to another, or it is only connected to itself
the choice of self-connection would reject the join, would be a non-productive 'no', though it is always pedantically available
is it really? surely, when we have chosen a connecting portset, then that is it done with - it can't be denied then

as soon as a choice has any entry, then we lose the possibility of self-connection: something definite is being said here
it would be a waste of time to indicate the positive possibility of self-connection; but as soon as we lose that innocent possiblity -
that is, as soon as we know a port is connected to another, then we must mark its difference

can there ever be a choice between isolation and a connection?
I'm momentarily happy to say - no; at least, not a positive choice

------

simple case: a disjunction is built up by composition of atoms

but combining isn't the way to build up disjunctions: combination can only dissolve differences as everything tends towards gloop
so trying to build disjunctive graphs by combination is a fool's errand

where do disjunctive graphs come from then?

the ports themselves: often a relation will have a leg with one of two values, a boolean
a disjunction implies a hard choice, and comparisons are required for choices
though it would also be possible to explicitly bind such
and a disjunct on the right then creates cascading disjunctions on the left

and the intercession of a choosy port is by imposition
so - combination must cope with preexisting disjunction

and - how might imposition work?
we merge in a single small identical binding, albeit with a payload

this is for domains? though domains are just another way to get a disjunction
a portset of one is sufficient for a payload: by itself it's doubtlessly pointless

an empty entry on a graph may be thought of as unity in terms of portsets, but emptiness in terms of payloads
it seems that unity is the sane default for both portsets and domains: a unity domain says nothing, but that the domain equals itself: no content
a null though is a forceful negative: never needs stating

A|B|Never & Identity

anding Identity means nothing as Identity is always true
and oring Never means nothing, as Never is nevr true, and so never interferes
but the other way round, both values destroy the computation

So, unstated, Identity is always assumed
whereas Never is never assumed, unless we have a disjunction, in which it is implicit
Never can change things only when it is in one position, in place of the implicit Identity
it therefore must be explicitly stated

------------

where were we this morning?

quite convinced that portsets only appeared in indices - such is the only way to represent the multifaceted choices involved 
(unless we were to reconstruct the choosability of things from overlaps on the hoove)

which is fair enough; we have a single layer of disjunctions; each time we make a choice, then this choice must propagate to rule out other choices

at the level of overlapping portets, this culling appears most straight forward - but we have to think of domains as well and extensive, repeated propagataions
of values. the idea of having subgraphs creates a place for memoizations. 

I need to mull over propagations again, moving away from the simpler world of portsets...

----------

as a new atom is merged in, we obviously create a new graph that now needs normalising - we have to see if all the nodes we have recently touched are at peace with their reformed surroundings
or, we do it on each smallest change (the sooner we integrate sometimes the better, though batching is also most efficient - there must be a sweet spot here) 

say we merge in a fragment, then normalize by propagation
each port is given a chance to say what's what: the impulse is passed to it, it checks with its hinterland, and as it goes updates domains

it gets to a disjunction: or rather, a singular port on one side of a relation is split by traversal of the relation, and the propagation proceeds in two parts

if this propagation were destructive in its simplifications on choice, there may be difficulties in its updating of the underlying graph
though the propagation only knows its one niche; though the joining after the forking must occur, and this must add together possiblities from different branches

on reciprocal join afer fork, it's newly decided bindings would be poured back into the downstream graph, and previous precipitations from the same would be replaced
we would now the origin of a disjunct from the env attached to it: though not all such precipitates would be of the immediately returned graph, but of ulterior ones behind

the return should carry with it a record of graphs replaced then, an increasing bag of obsolete bindings, which on return will be replaced on favour of fresh ones
though this only applies to bindings on affected ports; a graph may still hold true if reachable by other routes

---

so progress by mutilation of the graph seems alright, as on return we will return to the unmutilated original; but we are conceiving again of subgraphs 
on choice of a subgraph, we must rid ourselves of compatriot choices across the root, as these will show through as possibilities even in the branch

with portsets it is easy, as these are shared across ports and have their own logic of intersection; domains on the other hand are propagated by a secondary system
of reactive relations, of springy reflexes computed by exhaustive search

so when we choose one particular domain, it is true that we have rejected the others; but to truly enter the consistent world into which this choice leads us, we have to
propagate until we find rest - the system is one of simplified pushing and pulling

----

is it right then to treat the two systems separately? a system of portsets can suit itself, it seems, but if specialise to it, we won't stretch to the greater subtlety of the domain system
this is why the domain system should be our guide: we need to cope with it

maybe a domain system without portsets would be a good start? just ports with no bindings - or rather, with no choice of bindings

the case for a choice of bindings (again): activation of blocks on conditions; latches that activate
and such a latch would activate only on propagation: when a value becomes acceptible, the propagation will penetrate the block, it will flood its relations and flow back its findings
which will precipitate below as normal

summoning bindings from below to feed propagations above is fine as we can't know which bindings below are ruled out except by such rifling through them: and the findings will be stored above on the subgraph rather than in the root

but portsets are a different kettle of fish: once we choose one portset, we know which other portsets must be binned in the current branch: those that don't agree with our choice 
so the choice of portset itself, even without choice of domain, has an effect on the graph
we could, if we wanted, only half choose at a disjunction: we could choose a portset and see what further choices we could make from there

the portset choice is a distinct act, rendering to us a simplified graph of further choices
though such a choice does not access necessarily a memoised subgraph, but a dynamically calculated vision
nevertheless it returns to us a graph

if suddenly a new portset is available, and we choose it, we will find then not a completely new graph, because our new site will be derived from the previous, but having taken it,
no subgraphs will be available - this absence will however only mean thoroughgoing delegation to the original - propagation will still proceed

will we still see the bindings of ports under conditions of the previous portset regime? no - because the portset logic will have ruled those out that are destroyed by the simple logic of
portsets; but still others will have had their payload domains influenced by the other regime; this is but a momentary inconsistency however, as our current propagation will now tear through,
and memoise its own values in the new spaces afforded to it

------

portsets then are the first front, always the first choice 
and when we choose a portset, other portsets that no longer are available must be expunged from our options: this is done by scanning the ports spanned by the chosen portset, and enumerating the competing portsets newly vanquished

if there is only one portset left elsewhere after this simplification, does this mean that that portset must be chosen? if so the wave of simplification can proceed even further

no - because it might be that by our choices there is no possiblity of linkage between ports, where before there was

------

portsets have their own logic, that then lets the logic of domains build on top of it

what we're after ultimately is a responsive graph
we can get this with portsets alone

when we have domains too, then the graph of portsets opens up to let us harmonise them on their own terms

so - we should be able to build the first layer by itself

------

do group graphs lead to other group graphs? the idea would be that we have sufficient information in our current graph, and just need to trim it down on the occasion of a choice

on choosing, we'd now find ourselves with a different graph, with all the impossibilities plucked out

so we wouldn't have to carry with us subgraphs here, we'd just work them out on the fly
would we? WOULD WE?

the idea is, again, that we'd be able to whittle our graph as we went happily enough. Our choices can propagate themselves into ins and outs, simply enough.

-------------------------

1: A B   C   _ _
2: A   *   = _ _
3:   B   C   _ _

- what overlaps C?
  first discovered overlap is 1:A|B,
  only one can be true

so at this moment of first choice of first option, we get rid of what we reject
(we must do to avoid interactions elsewhere in the combination)

so - do we collect all the groups to be merged, and all the groups to be collected?
basically need to walk the graph collecting these

we don't need to actually alter the graph then - we can protect ourselves with a set of guards, rendering the bad invisible

and when we've finished walking in our particular disjunct, we can throw the bag of invisibility away
(there is an alternative here in actually simplifying the graph as we go)
either way, we walk and we accumulate

we'd basically accumulate a list of these replacement specs, a list of simple ops to perform on the graph
the first would be the replacement of a set of graphs with a new one

the second actually simpler operation would be to add, not replace a fresh group
it's almost like the first option is simply this add prepended with a delete...

the simple graph ops would then be addGroups/deleteGroups; after this we just need to walking the graph to merge

--------------------------

AddGroups
RemoveGroups

simple enough: groups simply overlap


-------------------------------------

both right and left have their disjuncts;
but we're collecting by choice onto the left because we expect it to be the larger

the idea is (now) to collect together actions to finally perform on the left graph

our only ops are to remove and to add groups
that's all we can fundamentally do...
so these are the actions we have to plan

as soon as we visit the first rh option, if there are any overlaps, we know that those overlaps must be removed; though
we don't know what we'll add in its place yet

enumerating the rh options must itself proceed portwise, as the structure of the disjunctions is only given here

each disjunction must contribute a separate addition

but responsibility for structuring the groups is given to the sink graph; we just need to know what groups to create

it's true that each rh graph must be combined into the left
we could just then enumerate these groups

each rh group then intersects with groups on the left;
each rh group contributes its own replacements for graphs on the left too

this is not true: two separate groups on the right, via the intersession of a common overlapper, will create only one on the right

---

each point on the right could cast its vote, so to speak, and the votes would be coalesced into a consistent set of groups
each vote would suggest an action, with source groups and output groups

the source groups would all finally be removed before the congealed output groups were emplaced

well - output groups wouldn't have to be deduced up front, as the collected source groups would always be combined
so, as we enumerate through the rh port options, we gather these clumps of combinable groups that should be represented

the question becomes, how should these specs be grouped together to preserve the structure necessary in the output?
which ones can be combined into big groups, and which ones can't?

by themselves, these atoms of activity will multiply the disjunction
but the act that achieves this great loss is the flattening of them all - and we're not there yet, we've not yet committed that crime!

--

what we really have is a graph of groups, some of which are linked by disjunctions of the entire group
whereas others ar enot linked at all, and can sit next to each other if need be

so per-port indexes are on projection of this underlying structure, and the hashset of groups its an efficient flattening of the same

there is though a real structure underneath
now we have to conceive of it in various scenarios

---------

1: A B
2: A   
3:   B
4: C

(A^B)|C

-------

1: A B   C   AC BC
2: A   *   = AC
3:   B   C      BC

(A^B)*C = AC^BC

-------

1: A B   D   AD BD
2: A   *   = AD
3:   B          BD
4: C         C

here it's obvious this is lacking: the C is always available in both disjunctions

(A^B)|C*D = (AD^BD)|C

the above bit is also needed to represent it all fully

------

though - fully? who knows... maybe every graph of relations can be simplified so
though I doubt it

so, the best representation is the graph of relations between groups

when adding in a group, it must take up a default 'or' relationship to the original groups of the graph, as a completely new possibility

though seemingly freefloating, is does even by this enter proper disjuntion relationships
each port can only be bound to one group

this then raises doubts about how simple an 'addition' really is

well - an addition is a simple way to relate to the whole - the C above just sits there, circumspect
it does not combine, it is added simply into the graph

but if it's in contention, then it seems it must either combine or it must add
which will it do?

but the two actions are differently paramterised: adding is just a shovelling in of a new possibility; combining requires targeting with other combinees
so the simpler of the two is certainly adding; and interfering with the possibilities of the graph is not an unreasonable thing for it to do

the standard OR isn't much of a relation at all: in fact it is the absence of a relation, other than that at least one must be true
and so we realise: it's not an OR, as both sides of it must be true... it's actually an '&'!

------------------

1: A B   D   AD BD
2: A   *   = AD
3:   B          BD
4: C         C

(A^B)&C*D = (AD^BD)&C

----

1: A B
2: A   C
3:   B C

(A^B^C)

----

1: A B
2: A
3:   B C

(A^B^C)

but A and C are compatible here...
....

-----

1: A B
2: A   C

A^B,
A^C

this is a better representation: the relationship between B and C is just left undetermined

----

1: A B
2: A
3:   B C

A^B,
B^C

the top grid does contain the bottom, in a way, as in, with some risk of ambiguity, or with added weight of inference,
you can work back to regain these relationships
the rules of the place are such to allow distillation of these relationships

they are derived like per-port indices are derived

indices are helpful in navigation
maybe the derived group relationships are helpful in merging
maybe they too should be maintained by the graph

when adding, do we want to be able to add in a relationship at the same time?
if we did this, combination would be done by not specifying any relationship

--

if relationships were treated as fundamental, not just as derived from the set of groups themselves,
we could pile in groups with relationships, store them as such, and only combine them lazily
basically the state pre-combination would be suspended within the structure

this would stop us having to preemptively merge and studiously maintain integrity
but - the inner combinations would be costly down the road; memoisatoin may be possible here - hmm nope nope nope

even if we do specify relationship when we add the group, this would boil down to more primitive add/remove ops underneath

-----

so - when we add/remove groups, we should also maintain an index of group relationships !!!!!!!!!!!
alongside the per-port indexes already known

and there is only one kind of relationship: disjunction

but... how would this help us when it comes to merging?

we wouldn't have to enumerate via the port index - we'd enumerate the groups for themselves, thus simplifying things
we defo need to know the relationships in the merging - doing it this way happily splits off half the work
if we can track these relationships, the final merge algorithm will certainly be simpler, because it won't have to
regather this information from scratch

----------------------------

we say - this is a group and it is disjunct from these other groups
we can say it is individually disjunct from another group of groups

if we want to combine one group into a variously disjunct graph


1: A       C   CA   C
2: A ^ B * . = CA ^ B
3:     B   .        B

A^B

C, in intersecting with A, must multiply across all disjuncts in which A as a group is involved


A     D   AD D
A B * . = AD B
  C   .      C

A^B       AD^(D,B)
          C

---------------------

so, questions still around how to structure the actual storage (although like an actual graph seems like a go-er)
what needs some satisficing now is - how will the merge happen even with a happily-preserved graph?

the thing is with disjunctions - they cover all the possible ports of each disjunct, and so the mergee doesn't need to intersect with more than a single
disjunct to have to cover them all

or rather, as disjunctions happen at the port level...
the disjuncts to spread across are determined by the coverage of the mergee, by its intersection with some disjunctions

if the mergee is a group of a single port, then it only has to care about the disjunct spaces that affect it - ie not all of them

disjunctions again are per-port rather than between groups as a whole

when merging, we'd enumerate all the port disjunct intersected by the source group
and gather them into a pliable, fidelous structure - this intermediate representation of only the groups we need to care about, would contain information about disjuncts
as previously conceived - 

part of the plan phase, where we gather old groups, and come up with our replacements
then when we apply them, we know to remove the old ones before adding the new ones

-----

its like the gathered ops needed to do the merge would have to follow the grain of the source graph
if there are two source groups in disjunction, they should be considered separately
and add up to two separate adds

for every group disjunction (as opposed to port disjunction) a new set of replace/adds should be emitted

it's like, again, we should be enumerating disjunctions in the source
duplications in removals of target groups are fine because the operation is idempotent - already-removed left groups can't be removed twice, but they won't complain about it

so, how to enumerate disjunctions?

(it'd also be possible to limit the rhs to a single group - each binding would then be merged in one at a time)

how to enumerate disjunctions?
well - how about just enumerating groups?

no - because some rhs groups shouldn't be added separately
some are not in disjunction with each other, and would be merged as one into the left

we must enumerate the groups somehow though, and a common non-disjunct group may be enumerated first
this would create a single replace/add op - although, this would tie in whatever other groups were linked to it via overlap

in merging one group, we need to follow not just the groups that are immediately intersected by it, but the secondary groups that are intersected by each target group in the source
it's like a game of table tennis, paddling back and forth

the first rh group is taken, and in being gathered it is uprooted, leaving a rh graph denuded - this is the current graph we carry with us
and in each mirroring, we gather what is to merged together in a branching structure, until we have a denuded left and right
at this point we can add in our mergeables into the left

questionable whether we need to denude the left - in fact do wereally need to denude the right too?
NO we don't remove, as different disjuncts should be able to find the same secondary group twice

when we enumerate each as a source however, won't we gather the same string of groups just from the other end?
these can be deduped in the intermediate step maybe

it won't be found twice if it has been removed from the graph though - 

---------------------------------

so - the probelm is that forked disjunctions won't be aware of joins 
we'll start off ping-ponging from two disjuncts we are enumerating; we end up lining up two identical sets of merges

in fact we don't even need disjuncts for this to occur, but we can usually sidestep the problem by removing already-projected groups from the graph we are enumerating
this is more complicated in the presence of disjuncts however

in the presence of disjuncts, we'd either ignore the disjunction in our simplifying of the source graph,
which would lead to common possibilities being expunged too soon
or we'd gather the denuded source in line with the disjunctions, and then get duplication because we hadn't expunged it from the original root disjunct

what we need is a join to match the fork

since what we're collecting is effectively a set of removables, we could say - at the point of joining back into the whole, if a removal appears in each disjunct enumerated,
then it should also be communicated back to the whole

(our simplest care is however to rustle up an algorithm that works except for disjunctions)

----

but we are in the business not just of accumulating denudation on the right, but also on the left - we are perfectly balanced at this point

and as we paddle leftward, it is impossible on the serve that we don't enumerate the opposing disjunct fully - uncertainty on this point only intrudes on the rebound
and rebounds bounce to each side, with the same implied dynamic: some collocated disjuncts will be merged and entirely replaced, while others will be only partially taken
these partials should be left sitting in their spot, await future merges

this partial won't be removed totally from the root if the enumeration of possibilities isn't at each stage total - ie if there's one enumerated disjunct in the chain that
leaves it alone, it will remain available in the root

---

fork and join, fork and join, fork and join

disjuncts are what, per group or per port? I've been imagining them as being per group, though per-port is the original and most fidelous index

the big problem with per-port is that the disjunction can't be exhaustive (can it?)
it's possible that in some worlds a port may be connected only to itself, while in others it will be connected to a larger group
in this case, enumerating the disjuncts per port would only(?) show one of these possibilities

each port, no matter what other options it has, is always possibly self-connected only - the ever-available escape-hatch
as such, each graph as a whole also has a foundational option of self-identity, which is completely devoid of information, other than saying /it is/

to enter the informational content of the graph, we have to make the initial choice to read it beyond acknowledging it

the possibility of identity should be included in the merge - though this will leave the rhs unaffected
if this path of ignorance is chosen, it would seem that the lhs would remain exactly as it is via such a merge
that is, even after a graph-wide merge, the original should still be there as a possibility
maybe we implicitly choose by invoking the merge in the first place

per-port too, this is problematic, because it implies each port, once merged, retains not just its possibility of self-identity, but also it's two input originals
each choosing of identity is a 'do-nothing' that leaves us stuck in time

the problem with it is the idea that we can progress at one point but stay stuck in the past at another. This is wrong: everything must be consistent.
Choosing not to choose is ok, as long as that doesn't coexist with choice in the same frame

So - we can choose port identity only when we have made no other implicating choice - it's only available /right at the beginning/ and soon vanishes

but we're saying the identity is commonly available in the empty space of the graph; this is because it is untouched, and so no choice has touched it

---

identity should then be an explicit option in disjuncts where it is available

it should be explicitly available in each first choice (though its projection would achieve little)
but when we make one choice, it's extinction should follow

this has repercussions now for per-port indexing and its mechanism:
when we add groups in to a graph, it seems identity should always be represented in the indices

and this is not being pedantic, despite appearances - otherwise it implies we have to choose for each port,
whereas a port may very much retain its option of identity even after other choices on the graph

so if we want per-port indexing, we should explicitly retain identity as an option
but as soon as we make one choice, we rule out and expunge these identities elsewhere

---

where does this leave us with our merging?

it suggests we're back in the world of per-graph disjunctions

and calls into question the simplicity of adding - if all we really have is a set of groups
how can we know if one set is optional? easy - because all sets are initially optional

other indices could then be derived from the primal set of groups

but how would we represent intermediate graphs, where this implicit identity is expunged?

----

identity isn't /always/ possible however, except for in a pedantic way

if a group sits by itself, it must be true, and identity is not to be considered - it is a waste
tight, concise, precise = don't represent identity in such cases

it is possible to work out which groups and which ports have a true possiblity of identity given the rest of the graph
think of it as a process of shrinkwrapping - idiosyncracies in the structure give us alterable gaps, pockets of impossibility
or as trying to lay an interconnected system of blocks down flat

all this is deducible just from a set of groups - this would keep our base operations to adding and removing groups
though it's doubtful these are the right base ops for the domain, they would be easiest to maintain

when adding a new group, that new group would register itself as a possibility on each grouped port
if it is by itself and non-intersecting, it will sit as the one and only choice for its ports
but if it overlaps with a doubtful intersection, and this is its sole support
then it must also take on this doubtfulness

certainty kills doubtfulness - a group only needs a little bit of certainty, or nothing at all, to be certain

then if we remove a group, this may remove the certainty attached to other groups, and they might fall into doubtfulness afresh
so we can continue to add and remove possible groups, but the derivation of indices from these becomes more difficult

removal might also make groups more certain, which is good when we simplify

but less certain? I'm not sure this would actually happen - or at least it shouldn't happen anyway

------

we've basically fallen again into a full graph approach
well, no - we have retained the simplicity of adding and removing groups

and have taken on work into the GroupMap in making the indices more substantial

adding a group adds a disjunct possibility if it happens to overlap with another

this other may have been happily minding its own business in its own certainty when, with the addition of the new group,
it became possible that the original graph doesn't actually exist

so adding a group here increases uncertainty

------

disjuncts are the only way in which groups relate to one another at rest

a group only has identity listed as a competing option if it is in disjunction with another 
and is hanging free

--

if the groups were in a graph, with linkages of disjunction between them, alongside a kind of coexistence
but to get to this graph, we'd still need to start from a port-by-port account

intersecting groups would all be in disjunction with each other;
but not necessarily in the same disjunction

again, there would be no root, just a set of groups involved as a kind of primary index

each group added would come into relation with other groups according to its overlaps

the group would be added to the flat set, and then crossrelated

(then the secondary per-port index would be maintained)

and this would help the merging how?
well, it would certainly be additional information readily available to ease the imagination

--------

HOW WOULD THE MERGE WORK THEN?

that is the big question
say we have per-port indices that respect identity (we currently don't)
and a handy graph representation readily available, then what?

we begin by enumerating groups on the right
we choose any old group, as at the root all are equal, no structure at ths point

we now remove the group from our marginal graph
and enumerate intersecting groups on the left - this is done by collecting all the possible groups available by the port indices
and going through these one by one

not all of these will be in disjunction with each other: at this point of gathering groups, we need to know which ones we can gather at the same time
and which ones need to be enumerated separately

---------

A           DA 
A B *   D = DA DBC
  B   C        DBC
  

---
CASE 1:  

A
A B *   D = 
  B   C D

above, working from C, collects B, and would from there collect D, except for the realisation that D is in an alternate world from C

port indices are needed to collision-detect, gathering the groups we will intersect


---
CASE 2:

A     C
A B * 
  B   C
  
here C, working via port indices, collects both A and B
at this point we must realise that A and B are in disjunction



---------------------------

can we always work out disjunctions just from portsets?
we can if we take a portsets as a whole across a group: disjunctions are always discoverable there
which means we don't have to maintain group relations - it's up to the merger to find them

on the rebound however, we need to rearticulate again
based on our current bag of groups
as we bounce, we gather our current bag of groups
this is then used to articulate the denuded graph in front of us

----------------------------

Finding of this morning: both port indices and group relationships are needed

so - this gives us something simple and achievable to aim for
let's get group relationships going

-----

SIMPLE AND ACHIEVABLE!!!

- port indices should reflect identity where it's implicated
- groups should be wrapped, with sets of links also updated







